![image-20220430221717357](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220430221717357.png)

红色结点的孩子必定是黑色结点，确保了红黑相间，可以有连续黑，但不可能有连续红

![image-20220501231536528](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220501231536528.png)

满足红黑树的五条性质为什么就能保证最长路径不超过最短路径的两倍

即最长路径<=最短路径*2



新增结点的颜色是什么？为什么？



情况一 p为红（p为黑不用处理）

p和cur都为红

p为红->g为黑->u不确定

1. u为红时

处理:p和u都处理为黑，g处理为红  这条路径本来就是一红一黑 处理后相当于p,u交换了g的颜色,处理后依旧是一红一黑

若是g处理为红后，g的父亲也是红，则仍然存在两个连续的红，若符合上面情形则继续处理

2. u为黑时的情况  一定不是直接新增导致的 ，多半是第一种u为红变过来的，第一种情况处理后，祖父上面的情况里u为黑，即cur原来为黑，是第一种情况里的祖父，祖父由黑变红，则形成了cur为红，u为黑的情况

为啥u为黑一定不是新增导致的？如果是新增导致的 说明插入前就不是红黑树 一条路径有一个黑结点，另一条有两个黑色结点，

![image-20220430232309763](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220430232309763.png)

最多出现两个连续的红，指的就是cur和p

如何处理？旋转+变色 ；p一定要从红变为黑； g为黑，u为黑 转到下面去,再把p由红转黑，g和u转到下面去后黑色结点数目本来是没变的，但是因为p是祖父变色了，影响了这棵子树，就得把u由黑转红实现红黑树的平衡

此时p变为黑了 那上面是红是黑都行（不可能出现连续红了

![image-20220430234106934](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220430234106934.png)

![image-20220430234250337](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220430234250337.png)

> 本质上调节就是把每一棵树（子树）调节成红黑树

第二种情况 且是折线 双旋+变色



第二种情况可以直接break了，第二种情况旋转变色完cur出现在最上面为黑色，不必继续更新。

其中uncle不存在，就当做为空去写，因为rotateR和rotateL已经对uncle为空进行了处理，所以代码实现时不会出现空指针解引用的情况



可以把avl树旋转的所有情况用两张图表示出来 然后改一下博客



检查是否是红黑树  根据那几条规则来

算每条路径黑色结点的个数，采用传参的方式，然后先算一条路径的黑色节点作为基准值

走到空表示是一条路径，然后算出的黑色结点的个数和基准值去比较，相同返回true,否则返回false

红色节点的孩子一定得是黑的，但是孩子不一定存在，不如去去检查红色结点的父亲一定是黑的，不如就存在连续的红，不符合红黑树定义



给出一系列的随机值去进行测试



旋转本质上就只是改变了树的形状，并没有改变树的性质（二叉搜索树）

合理的旋转可以达到降低树的高度，又因本身不改变树的性质，所以合理的旋转可以降低树的高度（avl树）



红变黑==增加一个黑色结点

黑变红==考虑是否会出现连续的二红



