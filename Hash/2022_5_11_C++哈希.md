# C++哈希

> **下面把放入哈希表中的值记为key，index是key在哈希表中的位置**

### 哈希冲突

两个key通过同一个映射关系得到了相同的值，即他们需要放在同一个位置（通过key算出的index一样），这就是哈希冲突。

简而言之，**不同值映射到了同一个位置**.

> 哈希表的效率与哈希冲突的处理密切相关
>
> 举个例子，哈希表大小为10，a[]={1，2，3，4，5，15}，定义哈希算法为 index=key%表长，从前往后构造哈希表。
>
> 即数组从前往后算出的index分别为1，2，3，4，5，5，此时key=15的元素算出的index为5，但是5这个位置已经有了key为5的元素，这就是哈希冲突

### 负载因子

负载因子=哈希表中元素的个数/哈希表的大小

> 显然负载因子小于1，并且负载因子越大越容易产生哈希冲突（两个数放到一个位置的概率更大，大小为10的容器里放9个数冲突概率肯定比放一个数大）

## 哈希函数

一般采用除留余数法，即取模的方法，如key对表长进行取模得到index。

此外还有很多种，如平方取中，随机数法等等

## 闭散列

闭散列也叫开放地址法，发生哈希冲突时只要哈希表没满则说明哈希表中必有一个空位置存放这个值

### 处理哈希冲突

线性探测和二次探测。

> 这两个方法都是发生了哈希冲突才用的上的.

#### 线性探测

算出的index往后挨个找，找到一个空位置放入即可。

![线性探测](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B.gif)

#### 二次探测

算出的index依次加1，4，9，...这种数，直到找到一个空位置

> 二次探测放入的数据更散，但是可能死循环（代码测试二次探测时一组数据死循环了）

![二次探测](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B.gif)

#### 其它

还有别的办法解决哈希冲突，闭散列主要用的上面两种，

## 代码实现

### 结点

```c++
template<class K, class V>
struct HashData
{
	pair<K, V> _kv;
	Status _status = EMPTY;
};
```

结点的三种状态

```c++
enum Status//定义一下结点的状态，方便操作
{
	EMPTY,
	EXIST,
	DELETE
};
```



### 内置类型以外类型的映射值处理

内置类型以外的类型就是自定义类型和库里的一些类型如pair和string等

**我们利用仿函数得到相应的值**

```c++
template<class K>
struct HashFunc
{
	const K& operator()(const K& key)
	{
		return key;
	}
};
template<>//对字符串进行特化，模板进阶的内容
struct HashFunc <string>
{
	size_t operator()(const string& key)
	{
		size_t value = 0;
		for (auto e : key)
		{
			value = value * 13 + (size_t)e;//乘以131是BKDR发明的字符串哈希算法，*131等数效率更高
		}
		return value;
	}
};
```

仿函数传入key返回key有啥用？

以一般类型为例，如int，double等传进去直接返回它们本身的值，因为他们本身就是key。如STL中的set和unordered_set。

但是如果要传入pair呢？那就得我们自定义一个仿函数（如同处理string一样），可以写成下面这样

```c++
template<class K,class V>
struct HashFunc
{
	const K& operator()(const pair<const K,V>& kv)
	{
		return kv.first;
	}
};
```

> 仿函数写了如何用？传参时传入这个struct作为模板参数。
>
> ![image-20220520002710373](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220520002710373.png)
>
> 

### 结构

```c++
	template<class K>
	struct HashFunc
	{
		const K& operator()(const K& key) ;
	};
	template<>
	struct HashFunc <string>
	{
		size_t operator()(const string& key);
	};
	enum Status//定义一下结点的状态，方便查找
	{
		EMPTY,
		EXIST,
		DELETE
	};	
	template<class K, class V>
	struct HashData
	{
		pair<K, V> _kv;
		Status _status = EMPTY;
	};
	template<class K,class V,class Hash=HashFunc<K>>
	class HashTable
	{
	public:
		HashData<K, V>* Find(const K& key);
		bool Insert(const pair<K, V>& kv);
		bool Erase(const K& key);	
	private:
		vector<HashData<K,V>>_tables;
		size_t _n = 0;
	};
```

###  查找

思路：先算出key对应的index，如果这个位置存在且key与要查找的key相等就说明找到了，否则往后找，找到空的位置说明表中不存在这个key。

```c++
	HashData<K, V>* Find(const K& key)
	{
		if (_tables.size() == 0)
		{
			return nullptr;
		}
		
		Hash hash;
		size_t start = hash(key) % _tables.size();
		size_t i = 0;
		size_t index = start + i;//算出的index
		while (_tables[index]._status != EMPTY)//这个位置不为空
		{
			if (_tables[index]._kv.first == key
				&& _tables[index]._status == EXIST)//存在且值相等
                //判断是否存在是因为结点有一种可能的状态是删除
			{
				return &_tables[index];
			}
			else
			{
				++i;
				//index = start + i; // 线性探测
				index = start + i * i; // 二次探测
				index %= _tables.size();
			}
		}
		
		return nullptr;
	}
```

### 插入

思路：找到一个空位置直接放

具体来说，位置为空直接放，如果找到的位置已经有值了就通过线性探测/二次探测去后面找位置

> 值得注意的点是负载因子是0.7的时候或者刚开始表长度为0的时候得进行增容
>
> 增容拷贝原哈希表数据的方法：开一个新表，调用Insert函数插入数据到新表中，再交换新表和旧表即可。（vector的交换只交换指针，所以开销不大）

```c++
		bool Insert(const pair<K, V>& kv)
		{
			Hash hash;
			if (Find(kv.first))//原来的表中存在
			{
				return false;
			}
			if (_tables.size()==0||_n*10/_tables.size()>=7)
				//负载因子在0.7的时候扩容 不然可能导致死循环
			{
				size_t newsize = _tables.size() == 0 ? 10 : _tables.size() * 2;
				
				HashTable<K, V, Hash>NewHT;//搞一个vector出来行吗？可以，但是选用hashtable后面可以直接调用Insert插入数据更方便
				NewHT._tables.resize(newsize);
				for (auto& e : _tables)//这种传引用 不传引用得多拷贝一次
				{
					NewHT.Insert(e._kv);
				}
				_tables.swap(NewHT._tables);//交换之后NewHT就被销毁了
			}
			size_t start = hash(kv.first) % _tables.size();
			size_t i = 0;
			size_t index = start + i;
			//进行线性探测或二次探测
			while (_tables[index]._status==EXIST)//不等于空就一直往后走
			{
				//index++;//由于负载因子在0.7时扩容了所以不会死循环.
				i++;
				//index = start + i 线性探测
				index = start+i*i;
				index %= _tables.size();
			}
			//找到位置了
			
			_tables[index]._status = EXIST;
			_tables[index]._kv = kv;
			_n++;
			return true;
		}
```



### 删除

> 复用Find()即可，这里是一种伪删除，只是更改结点状态而不是删除数据。

```c++
bool Erase(const K& key)
		{
			
			/*	Hash hs;
				size_t index = hs(key) % _tables.size();
				while (_tables[index]._status==EXIST)
				{
					if (_tables[index]._kv.first == key)
					{
						_tables[index]._status = DELETE;
						return true;
					}
					index++;//线性探测
					index %= _tables.size();
				}
				return false;*/
			HashData<K, V>* ret = Find(key);
			if (ret == nullptr)
			{
				return false;
			}
			else
			{
				ret->_status = DELETE;
				return true;
			}
		}
```

### 测试

测试整形

```c++
	void test1()
	{
		int a[] = { 5, 3, 100, 9999, 333, 14, 26, 34, 5};//这组数据在二次探测时会死循环
		HashTable<int, int> ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Erase(3);
		cout << ht.Find(3) << endl;
	}
```

测试字符串

```cpp
void test2()
{
	HashTable<string, string, HashFunc<string>>ht;
	ht.Insert(make_pair("sort", "排序"));
	ht.Insert(make_pair("entity", "实体"));
	ht.Insert(make_pair("object", "对象"));
	ht.Insert(make_pair("buffer", "缓冲"));
	ht.Erase("sort");
	cout << ht.Find("sort") << endl;
}
```

### 析构，拷贝构造，构造函数

析构，结构选用了vector，vector会帮我们搞定

拷贝构造,没有涉及到深浅拷贝构造，vector会帮我们搞定

构造函数，给了缺省值，也没啥要传参初始化的情况，默认的也够用。

> 闭散列的哈希表可以理解为对vector进行了一次封装，vector的元素哈希结点也没开辟什么空间，所以也不会出现内存泄漏的问题，但是开散列采用链表的结构（链表是自己写的），所以需要自己去释放链表的空间。

## 开散列（哈希桶）

> STL里的unordered_set和unordered_map底层的哈希就选用了开散列结构

### 处理哈希冲突

采用链表的形式

![image-20220520171854746](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220520171854746.png)

- 那开散列的结构是不是不需要扩容？

需要的。以上图为例，表长就为10，我要放10000个数据，平均下来就算每个链表放1000个，那查找和删除指定元素的效率依旧不高。

- 那需要增容的话什么时候增容？

负载因子为1时增容

> STL库里默认是1
>
> ![image-20220520172601023](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220520172601023.png)

##  代码实现

####  查找

### 插入

### 删除











开散列

哈希桶的结构

插入时头插好还是尾插好？

负载因子到多少时扩容 扩多少  怎么保存原来的数据

 

成员变量仍然是table 所以还得交换

插入时的效率变化

![image-20220516231103534](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220516231103534.png)

插入 扩容的现代写法

查找  单链表的遍历

删除  能直接find去找吗？需要区分是否是头结点吗（单链表的删除）



当元素类型为string时如何取模？



构造与析构

为什么不用默认的？



拷贝构造和赋值

 

