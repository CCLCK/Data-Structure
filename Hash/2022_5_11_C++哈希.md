# C++哈希

> **下面把放入哈希表中的值记为key，index是key在哈希表中的位置**

### 哈希冲突

两个key通过同一个映射关系得到了相同的值，即他们需要放在同一个位置（通过key算出的index一样），这就是哈希冲突。

简而言之，**不同值映射到了同一个位置**.

> 哈希表的效率与哈希冲突的处理密切相关
>
> 举个例子，哈希表大小为10，a[]={1，2，3，4，5，15}，定义哈希算法为 index=key%表长，从前往后构造哈希表。
>
> 即数组从前往后算出的index分别为1，2，3，4，5，5，此时key=15的元素算出的index为5，但是5这个位置已经有了key为5的元素，这就是哈希冲突

### 负载因子

负载因子=哈希表中元素的个数/哈希表的大小

> 显然负载因子小于1，并且负载因子越大越容易产生哈希冲突（两个数放到一个位置的概率更大，大小为10的容器里放9个数冲突概率肯定比放一个数大）

## 哈希函数

一般采用除留余数法，即取模的方法，如key对表长进行取模得到index。

此外还有很多种，如平方取中，随机数法等等

## 闭散列

闭散列也叫开放地址法，发生哈希冲突时只要哈希表没满则说明哈希表中必有一个空位置存放这个值

### 处理哈希冲突

线性探测和二次探测。

> 这两个方法都是发生了哈希冲突才用的上的.

#### 线性探测

算出的index往后挨个找，找到一个空位置放入即可。

![线性探测](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B.gif)

#### 二次探测

算出的index依次加1，4，9，...这种数，直到找到一个空位置

> 二次探测放入的数据更散，但是可能死循环（代码测试二次探测时一组数据死循环了）

![二次探测](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B.gif)

#### 其它

还有别的办法解决哈希冲突，闭散列主要用的上面两种，

## 代码实现

### 结点

```c++
template<class K, class V>
struct HashData
{
	pair<K, V> _kv;
	Status _status = EMPTY;
};
```

结点的三种状态

```c++
enum Status//定义一下结点的状态，方便操作
{
	EMPTY,
	EXIST,
	DELETE
};
```

### 内置类型以外类型的映射值处理

内置类型以外的类型就是自定义类型和库里的一些类型如pair和string等

我们利用仿函数得到相应的值

```c++
template<class K>
struct HashFunc
{
	const K& operator()(const K& key)
	{
		return key;
	}
};
template<>//对字符串进行特化，模板进阶的内容
struct HashFunc <string>
{
	size_t operator()(const string& key)
	{
		size_t value = 0;
		for (auto e : key)
		{
			value = value * 13 + (size_t)e;//乘以131是BKDR发明的字符串哈希算法，*131等数效率更高
		}
		return value;
	}
};
```

仿函数传入key返回key有啥用？

以一般类型为例，如int，double等传进去返回一个值，他们本身就可以当作key。如STL中的set和unordered_set。

但是如果要传入pair呢？那就得我们自定义一个仿函数（如同处理string一样），可以写成下面这样

```c++
template<class K,class V>
struct HashFunc
{
	const K& operator()(const pair<const K,V>& kv)
	{
		return kv.first;
	}
};
```

> 仿函数写了如何用？传参时传入这个struct作为模板参数。
>
> ![image-20220519232145499](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220519232145499.png)





###  查找

思路：先算出key对应的index，如果这个位置存在且key与要查找的key相等就说明找到了，否则往后找，找到空的位置说明表中不存在这个key。



### 插入

### 删除

## 开散列

###  查找

### 插入

### 删除





闭散列

为什么需要

结构





开散列

哈希桶的结构

插入时头插好还是尾插好？

负载因子到多少时扩容 扩多少  怎么保存原来的数据

 

成员变量仍然是table 所以还得交换

插入时的效率变化

![image-20220516231103534](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220516231103534.png)

插入 扩容的现代写法

查找  单链表的遍历

删除  能直接find去找吗？需要区分是否是头结点吗（单链表的删除）



当元素类型为string时如何取模？



构造与析构

为什么不用默认的？



拷贝构造和赋值

 

